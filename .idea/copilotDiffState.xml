<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AJUSTES_CONTABILIZACAO.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AJUSTES_CONTABILIZACAO.md" />
              <option name="updatedContent" value="# Ajustes na Contabilização de Obras - Sistema Next.js&#10;&#10;## Data: 2025-11-13&#10;&#10;## Objetivo&#10;Aplicar as mesmas regras de agrupamento e contabilização do sistema Yii2/PHP no sistema Next.js, garantindo que:&#10;1. O totalizador de obras agrupe por `contrato_numero` (não por obra individual)&#10;2. O `status_id` seja referente ao último registro de cada `contrato_numero`&#10;3. A contabilização por status siga a mesma lógica da contabilização geral&#10;4. O botão de fechar tenha fundo vermelho&#10;&#10;---&#10;&#10;## Alterações Realizadas&#10;&#10;### 1. API Route (`app/api/consulta-obra/route.ts`)&#10;&#10;#### ✅ Ajuste na Contagem de Status&#10;**Antes:**&#10;```typescript&#10;const [statusCount] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#10;  `SELECT &#10;      status_id,&#10;      COUNT(*) as total&#10;   FROM (&#10;      SELECT &#10;          o.status_id,&#10;          ROW_NUMBER() OVER (PARTITION BY o.contrato_numero ORDER BY o.id DESC) as rn&#10;      FROM obra o&#10;      ${whereClause}&#10;   ) as subquery&#10;   WHERE rn = 1&#10;   GROUP BY status_id&#10;   ORDER BY status_id ASC`,&#10;  queryParams&#10;);&#10;```&#10;&#10;**Depois:**&#10;```typescript&#10;const [statusCount] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#10;  `SELECT &#10;      status_id,&#10;      COUNT(DISTINCT contrato_numero) as total&#10;   FROM (&#10;      SELECT &#10;          o.contrato_numero,&#10;          o.status_id,&#10;          ROW_NUMBER() OVER (PARTITION BY o.contrato_numero ORDER BY o.id DESC) as rn&#10;      FROM obra o&#10;      ${whereClause}&#10;   ) as subquery&#10;   WHERE rn = 1 AND contrato_numero IS NOT NULL&#10;   GROUP BY status_id&#10;   ORDER BY status_id ASC`,&#10;  queryParams&#10;);&#10;```&#10;&#10;**Motivo:** &#10;- Agora conta `DISTINCT contrato_numero` ao invés de todas as linhas&#10;- Filtra apenas registros com `contrato_numero IS NOT NULL`&#10;- Usa o `status_id` do registro mais recente (maior `id`) de cada contrato&#10;&#10;---&#10;&#10;### 2. Frontend (`app/consulta-obra/page.tsx`)&#10;&#10;#### ✅ Ajuste nos Cálculos Financeiros por Status&#10;&#10;**Antes:**&#10;```typescript&#10;const financeirosPorStatus = useMemo(() =&gt; {&#10;  const financeiros: { [key: number]: { total: number; valor: number; obras_com_valor: number } } = {};&#10;  &#10;  obras.forEach(obra =&gt; {&#10;    if (!financeiros[obra.status_id]) {&#10;      financeiros[obra.status_id] = { total: 0, valor: 0, obras_com_valor: 0 };&#10;    }&#10;    financeiros[obra.status_id].total += 1;&#10;    &#10;    if (obra.valor_contrato &amp;&amp; !isNaN(obra.valor_contrato) &amp;&amp; obra.valor_contrato &gt; 0) {&#10;      financeiros[obra.status_id].valor += obra.valor_contrato;&#10;      financeiros[obra.status_id].obras_com_valor += 1;&#10;    }&#10;  });&#10;  // ...&#10;}, [obras]);&#10;```&#10;&#10;**Depois:**&#10;```typescript&#10;const financeirosPorStatus = useMemo(() =&gt; {&#10;  // Primeiro, agrupar obras por contrato_numero e pegar a mais recente (maior id)&#10;  const ultimasObrasPorContrato = new Map&lt;string, Obra&gt;();&#10;  &#10;  obras.forEach(obra =&gt; {&#10;    const contratoKey = obra.numero_contrato || `sem-contrato-${obra.id}`;&#10;    const obraExistente = ultimasObrasPorContrato.get(contratoKey);&#10;    &#10;    // Manter apenas a obra com maior id (mais recente)&#10;    if (!obraExistente || obra.id &gt; obraExistente.id) {&#10;      ultimasObrasPorContrato.set(contratoKey, obra);&#10;    }&#10;  });&#10;  &#10;  // Agora calcular financeiros por status usando apenas as obras mais recentes&#10;  const financeiros: { [key: number]: { total: number; valor: number; obras_com_valor: number } } = {};&#10;  &#10;  ultimasObrasPorContrato.forEach(obra =&gt; {&#10;    if (!financeiros[obra.status_id]) {&#10;      financeiros[obra.status_id] = { total: 0, valor: 0, obras_com_valor: 0 };&#10;    }&#10;    financeiros[obra.status_id].total += 1;&#10;    &#10;    if (obra.valor_contrato &amp;&amp; !isNaN(obra.valor_contrato) &amp;&amp; obra.valor_contrato &gt; 0) {&#10;      financeiros[obra.status_id].valor += obra.valor_contrato;&#10;      financeiros[obra.status_id].obras_com_valor += 1;&#10;    }&#10;  });&#10;  // ...&#10;}, [obras]);&#10;```&#10;&#10;**Motivo:**&#10;- Evita contabilização duplicada de obras com mesmo `contrato_numero`&#10;- Usa apenas o registro mais recente de cada contrato (maior `id`)&#10;- Garante que o `status_id` seja do último registro&#10;&#10;---&#10;&#10;#### ✅ Ajuste nos Cálculos Financeiros por Regional&#10;&#10;**Aplicado o mesmo padrão de agrupamento por `contrato_numero`**&#10;&#10;```typescript&#10;const financeirosPorRegional = useMemo(() =&gt; {&#10;  // Primeiro, agrupar obras por contrato_numero e pegar a mais recente (maior id)&#10;  const ultimasObrasPorContrato = new Map&lt;string, Obra&gt;();&#10;  &#10;  obras.forEach(obra =&gt; {&#10;    const contratoKey = obra.numero_contrato || `sem-contrato-${obra.id}`;&#10;    const obraExistente = ultimasObrasPorContrato.get(contratoKey);&#10;    &#10;    if (!obraExistente || obra.id &gt; obraExistente.id) {&#10;      ultimasObrasPorContrato.set(contratoKey, obra);&#10;    }&#10;  });&#10;  &#10;  // Calcular financeiros por regional usando apenas as obras mais recentes&#10;  // ...&#10;}, [obras]);&#10;```&#10;&#10;---&#10;&#10;#### ✅ Ajuste nos Totais Gerais&#10;&#10;**Aplicado o mesmo padrão de agrupamento:**&#10;&#10;```typescript&#10;const totaisGerais = useMemo(() =&gt; {&#10;  // Primeiro, agrupar obras por contrato_numero e pegar a mais recente (maior id)&#10;  const ultimasObrasPorContrato = new Map&lt;string, Obra&gt;();&#10;  &#10;  obras.forEach(obra =&gt; {&#10;    const contratoKey = obra.numero_contrato || `sem-contrato-${obra.id}`;&#10;    const obraExistente = ultimasObrasPorContrato.get(contratoKey);&#10;    &#10;    if (!obraExistente || obra.id &gt; obraExistente.id) {&#10;      ultimasObrasPorContrato.set(contratoKey, obra);&#10;    }&#10;  });&#10;  &#10;  const obrasUnicas = Array.from(ultimasObrasPorContrato.values());&#10;  const total_obras = obrasUnicas.length;&#10;  // ...&#10;}, [obras]);&#10;```&#10;&#10;---&#10;&#10;### 3. Componente ObraDetalhes (`components/ObraDetalhes.tsx`)&#10;&#10;#### ✅ Botão de Fechar com Fundo Vermelho&#10;&#10;**Status:** JÁ ESTAVA CORRETO&#10;&#10;```typescript&#10;&lt;button&#10;  onClick={onClose}&#10;  className=&quot;px-6 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors font-medium&quot;&#10;&gt;&#10;  Fechar&#10;&lt;/button&gt;&#10;```&#10;&#10;---&#10;&#10;## Resultado Final&#10;&#10;### ✅ Problemas Resolvidos:&#10;&#10;1. **Totalizador de obras agrupado por contrato_numero**&#10;   - Antes: Contava cada registro de obra individualmente&#10;   - Agora: Conta apenas um registro por `contrato_numero` (o mais recente)&#10;&#10;2. **Status_id referente ao último registro**&#10;   - Antes: Poderia usar `status_id` de qualquer registro do contrato&#10;   - Agora: Sempre usa o `status_id` do registro com maior `id` (mais recente)&#10;&#10;3. **Contabilização consistente em todos os relatórios**&#10;   - Relatório por Status&#10;   - Relatório por Regional&#10;   - Totais Gerais&#10;   - Gráfico de Pizza&#10;   - Todos seguem a mesma lógica de agrupamento&#10;&#10;4. **Botão de fechar vermelho**&#10;   - Confirmado que já estava implementado corretamente&#10;&#10;---&#10;&#10;## Lógica Aplicada (Baseada no Sistema Yii2/PHP)&#10;&#10;### Regra Principal:&#10;```&#10;Para cada contrato_numero:&#10;  1. Buscar todos os registros da tabela 'obra' com esse contrato_numero&#10;  2. Ordenar por 'id' DESC (mais recente primeiro)&#10;  3. Selecionar apenas o primeiro registro (ROW_NUMBER() = 1)&#10;  4. Usar o status_id deste registro para contabilização&#10;  5. Contar apenas 1 obra por contrato_numero&#10;```&#10;&#10;### Query SQL (Referência):&#10;```sql&#10;SELECT &#10;    status_id,&#10;    COUNT(DISTINCT contrato_numero) as total&#10;FROM (&#10;    SELECT &#10;        o.contrato_numero,&#10;        o.status_id,&#10;        ROW_NUMBER() OVER (PARTITION BY o.contrato_numero ORDER BY o.id DESC) as rn&#10;    FROM obra o&#10;) as subquery&#10;WHERE rn = 1 AND contrato_numero IS NOT NULL&#10;GROUP BY status_id&#10;ORDER BY status_id ASC&#10;```&#10;&#10;---&#10;&#10;## Testes Recomendados&#10;&#10;1. Verificar se obras com mesmo `contrato_numero` são contadas apenas uma vez&#10;2. Confirmar que o `status_id` exibido é sempre do registro mais recente&#10;3. Validar que os totais em todos os relatórios são consistentes&#10;4. Testar filtros de status e regional após as alterações&#10;5. Verificar se o gráfico de pizza reflete os valores corretos&#10;&#10;---&#10;&#10;## Arquivos Modificados&#10;&#10;1. `app/api/consulta-obra/route.ts` - Query de contagem de status&#10;2. `app/consulta-obra/page.tsx` - Cálculos financeiros (status, regional, totais)&#10;3. `components/ObraDetalhes.tsx` - Verificado (já estava correto)&#10;&#10;---&#10;&#10;## Observações Importantes&#10;&#10;- A lógica de agrupamento é aplicada em **tempo de execução** no frontend usando `Map` para otimização&#10;- O backend já retorna as obras filtradas, mas o agrupamento adicional garante consistência&#10;- Todos os cálculos financeiros agora seguem o mesmo padrão de agrupamento&#10;- O código está otimizado com `useMemo` para evitar recálculos desnecessários&#10;&#10;---&#10;&#10;**Desenvolvedor:** GitHub Copilot  &#10;**Data:** 13/11/2025  &#10;**Status:** ✅ Concluído&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>