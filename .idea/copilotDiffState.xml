<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AJUSTES_CONTABILIZACAO.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AJUSTES_CONTABILIZACAO.md" />
              <option name="updatedContent" value="# Ajustes na Contabilização de Obras - Sistema Next.js&#10;&#10;## Data: 2025-11-13&#10;&#10;## Objetivo&#10;Aplicar as mesmas regras de agrupamento e contabilização do sistema Yii2/PHP no sistema Next.js, garantindo que:&#10;1. O totalizador de obras agrupe por `contrato_numero` (não por obra individual)&#10;2. O `status_id` seja referente ao último registro de cada `contrato_numero`&#10;3. A contabilização por status siga a mesma lógica da contabilização geral&#10;4. O botão de fechar tenha fundo vermelho&#10;&#10;---&#10;&#10;## Alterações Realizadas&#10;&#10;### 1. API Route (`app/api/consulta-obra/route.ts`)&#10;&#10;#### ✅ Ajuste na Contagem de Status&#10;**Antes:**&#10;```typescript&#10;const [statusCount] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#10;  `SELECT &#10;      status_id,&#10;      COUNT(*) as total&#10;   FROM (&#10;      SELECT &#10;          o.status_id,&#10;          ROW_NUMBER() OVER (PARTITION BY o.contrato_numero ORDER BY o.id DESC) as rn&#10;      FROM obra o&#10;      ${whereClause}&#10;   ) as subquery&#10;   WHERE rn = 1&#10;   GROUP BY status_id&#10;   ORDER BY status_id ASC`,&#10;  queryParams&#10;);&#10;```&#10;&#10;**Depois:**&#10;```typescript&#10;const [statusCount] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#10;  `SELECT &#10;      status_id,&#10;      COUNT(DISTINCT contrato_numero) as total&#10;   FROM (&#10;      SELECT &#10;          o.contrato_numero,&#10;          o.status_id,&#10;          ROW_NUMBER() OVER (PARTITION BY o.contrato_numero ORDER BY o.id DESC) as rn&#10;      FROM obra o&#10;      ${whereClause}&#10;   ) as subquery&#10;   WHERE rn = 1 AND contrato_numero IS NOT NULL&#10;   GROUP BY status_id&#10;   ORDER BY status_id ASC`,&#10;  queryParams&#10;);&#10;```&#10;&#10;**Motivo:** &#10;- Agora conta `DISTINCT contrato_numero` ao invés de todas as linhas&#10;- Filtra apenas registros com `contrato_numero IS NOT NULL`&#10;- Usa o `status_id` do registro mais recente (maior `id`) de cada contrato&#10;&#10;---&#10;&#10;### 2. Frontend (`app/consulta-obra/page.tsx`)&#10;&#10;#### ✅ Ajuste nos Cálculos Financeiros por Status&#10;&#10;**Antes:**&#10;```typescript&#10;const financeirosPorStatus = useMemo(() =&gt; {&#10;  const financeiros: { [key: number]: { total: number; valor: number; obras_com_valor: number } } = {};&#10;  &#10;  obras.forEach(obra =&gt; {&#10;    if (!financeiros[obra.status_id]) {&#10;      financeiros[obra.status_id] = { total: 0, valor: 0, obras_com_valor: 0 };&#10;    }&#10;    financeiros[obra.status_id].total += 1;&#10;    &#10;    if (obra.valor_contrato &amp;&amp; !isNaN(obra.valor_contrato) &amp;&amp; obra.valor_contrato &gt; 0) {&#10;      financeiros[obra.status_id].valor += obra.valor_contrato;&#10;      financeiros[obra.status_id].obras_com_valor += 1;&#10;    }&#10;  });&#10;  // ...&#10;}, [obras]);&#10;```&#10;&#10;**Depois:**&#10;```typescript&#10;const financeirosPorStatus = useMemo(() =&gt; {&#10;  // Primeiro, agrupar obras por contrato_numero e pegar a mais recente (maior id)&#10;  const ultimasObrasPorContrato = new Map&lt;string, Obra&gt;();&#10;  &#10;  obras.forEach(obra =&gt; {&#10;    const contratoKey = obra.numero_contrato || `sem-contrato-${obra.id}`;&#10;    const obraExistente = ultimasObrasPorContrato.get(contratoKey);&#10;    &#10;    // Manter apenas a obra com maior id (mais recente)&#10;    if (!obraExistente || obra.id &gt; obraExistente.id) {&#10;      ultimasObrasPorContrato.set(contratoKey, obra);&#10;    }&#10;  });&#10;  &#10;  // Agora calcular financeiros por status usando apenas as obras mais recentes&#10;  const financeiros: { [key: number]: { total: number; valor: number; obras_com_valor: number } } = {};&#10;  &#10;  ultimasObrasPorContrato.forEach(obra =&gt; {&#10;    if (!financeiros[obra.status_id]) {&#10;      financeiros[obra.status_id] = { total: 0, valor: 0, obras_com_valor: 0 };&#10;    }&#10;    financeiros[obra.status_id].total += 1;&#10;    &#10;    if (obra.valor_contrato &amp;&amp; !isNaN(obra.valor_contrato) &amp;&amp; obra.valor_contrato &gt; 0) {&#10;      financeiros[obra.status_id].valor += obra.valor_contrato;&#10;      financeiros[obra.status_id].obras_com_valor += 1;&#10;    }&#10;  });&#10;  // ...&#10;}, [obras]);&#10;```&#10;&#10;**Motivo:**&#10;- Evita contabilização duplicada de obras com mesmo `contrato_numero`&#10;- Usa apenas o registro mais recente de cada contrato (maior `id`)&#10;- Garante que o `status_id` seja do último registro&#10;&#10;---&#10;&#10;#### ✅ Ajuste nos Cálculos Financeiros por Regional&#10;&#10;**Aplicado o mesmo padrão de agrupamento por `contrato_numero`**&#10;&#10;```typescript&#10;const financeirosPorRegional = useMemo(() =&gt; {&#10;  // Primeiro, agrupar obras por contrato_numero e pegar a mais recente (maior id)&#10;  const ultimasObrasPorContrato = new Map&lt;string, Obra&gt;();&#10;  &#10;  obras.forEach(obra =&gt; {&#10;    const contratoKey = obra.numero_contrato || `sem-contrato-${obra.id}`;&#10;    const obraExistente = ultimasObrasPorContrato.get(contratoKey);&#10;    &#10;    if (!obraExistente || obra.id &gt; obraExistente.id) {&#10;      ultimasObrasPorContrato.set(contratoKey, obra);&#10;    }&#10;  });&#10;  &#10;  // Calcular financeiros por regional usando apenas as obras mais recentes&#10;  // ...&#10;}, [obras]);&#10;```&#10;&#10;---&#10;&#10;#### ✅ Ajuste nos Totais Gerais&#10;&#10;**Aplicado o mesmo padrão de agrupamento:**&#10;&#10;```typescript&#10;const totaisGerais = useMemo(() =&gt; {&#10;  // Primeiro, agrupar obras por contrato_numero e pegar a mais recente (maior id)&#10;  const ultimasObrasPorContrato = new Map&lt;string, Obra&gt;();&#10;  &#10;  obras.forEach(obra =&gt; {&#10;    const contratoKey = obra.numero_contrato || `sem-contrato-${obra.id}`;&#10;    const obraExistente = ultimasObrasPorContrato.get(contratoKey);&#10;    &#10;    if (!obraExistente || obra.id &gt; obraExistente.id) {&#10;      ultimasObrasPorContrato.set(contratoKey, obra);&#10;    }&#10;  });&#10;  &#10;  const obrasUnicas = Array.from(ultimasObrasPorContrato.values());&#10;  const total_obras = obrasUnicas.length;&#10;  // ...&#10;}, [obras]);&#10;```&#10;&#10;---&#10;&#10;### 3. Componente ObraDetalhes (`components/ObraDetalhes.tsx`)&#10;&#10;#### ✅ Botão de Fechar com Fundo Vermelho&#10;&#10;**Status:** JÁ ESTAVA CORRETO&#10;&#10;```typescript&#10;&lt;button&#10;  onClick={onClose}&#10;  className=&quot;px-6 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors font-medium&quot;&#10;&gt;&#10;  Fechar&#10;&lt;/button&gt;&#10;```&#10;&#10;---&#10;&#10;## Resultado Final&#10;&#10;### ✅ Problemas Resolvidos:&#10;&#10;1. **Totalizador de obras agrupado por contrato_numero**&#10;   - Antes: Contava cada registro de obra individualmente&#10;   - Agora: Conta apenas um registro por `contrato_numero` (o mais recente)&#10;&#10;2. **Status_id referente ao último registro**&#10;   - Antes: Poderia usar `status_id` de qualquer registro do contrato&#10;   - Agora: Sempre usa o `status_id` do registro com maior `id` (mais recente)&#10;&#10;3. **Contabilização consistente em todos os relatórios**&#10;   - Relatório por Status&#10;   - Relatório por Regional&#10;   - Totais Gerais&#10;   - Gráfico de Pizza&#10;   - Todos seguem a mesma lógica de agrupamento&#10;&#10;4. **Botão de fechar vermelho**&#10;   - Confirmado que já estava implementado corretamente&#10;&#10;---&#10;&#10;## Lógica Aplicada (Baseada no Sistema Yii2/PHP)&#10;&#10;### Regra Principal:&#10;```&#10;Para cada contrato_numero:&#10;  1. Buscar todos os registros da tabela 'obra' com esse contrato_numero&#10;  2. Ordenar por 'id' DESC (mais recente primeiro)&#10;  3. Selecionar apenas o primeiro registro (ROW_NUMBER() = 1)&#10;  4. Usar o status_id deste registro para contabilização&#10;  5. Contar apenas 1 obra por contrato_numero&#10;```&#10;&#10;### Query SQL (Referência):&#10;```sql&#10;SELECT &#10;    status_id,&#10;    COUNT(DISTINCT contrato_numero) as total&#10;FROM (&#10;    SELECT &#10;        o.contrato_numero,&#10;        o.status_id,&#10;        ROW_NUMBER() OVER (PARTITION BY o.contrato_numero ORDER BY o.id DESC) as rn&#10;    FROM obra o&#10;) as subquery&#10;WHERE rn = 1 AND contrato_numero IS NOT NULL&#10;GROUP BY status_id&#10;ORDER BY status_id ASC&#10;```&#10;&#10;---&#10;&#10;## Testes Recomendados&#10;&#10;1. Verificar se obras com mesmo `contrato_numero` são contadas apenas uma vez&#10;2. Confirmar que o `status_id` exibido é sempre do registro mais recente&#10;3. Validar que os totais em todos os relatórios são consistentes&#10;4. Testar filtros de status e regional após as alterações&#10;5. Verificar se o gráfico de pizza reflete os valores corretos&#10;&#10;---&#10;&#10;## Arquivos Modificados&#10;&#10;1. `app/api/consulta-obra/route.ts` - Query de contagem de status&#10;2. `app/consulta-obra/page.tsx` - Cálculos financeiros (status, regional, totais)&#10;3. `components/ObraDetalhes.tsx` - Verificado (já estava correto)&#10;&#10;---&#10;&#10;## Observações Importantes&#10;&#10;- A lógica de agrupamento é aplicada em **tempo de execução** no frontend usando `Map` para otimização&#10;- O backend já retorna as obras filtradas, mas o agrupamento adicional garante consistência&#10;- Todos os cálculos financeiros agora seguem o mesmo padrão de agrupamento&#10;- O código está otimizado com `useMemo` para evitar recálculos desnecessários&#10;&#10;---&#10;&#10;**Desenvolvedor:** GitHub Copilot  &#10;**Data:** 13/11/2025  &#10;**Status:** ✅ Concluído&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/IMPLEMENTACAO_ARQUIVOS_CONTRATO.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/IMPLEMENTACAO_ARQUIVOS_CONTRATO.md" />
              <option name="updatedContent" value="# Implementação de Arquivos do Contrato com Valores e Porcentagens&#10;&#10;## Data: 2025-11-13&#10;&#10;## Objetivo&#10;Implementar a funcionalidade de exibir arquivos do contrato com seus respectivos valores e porcentagens relativas, seguindo o padrão do sistema Yii2/PHP.&#10;&#10;---&#10;&#10;## Funcionalidade Implementada&#10;&#10;### Exibição de Arquivos do Contrato&#10;Similar ao sistema Yii2/PHP, agora o sistema Next.js exibe:&#10;&#10;1. **Tabela de Arquivos do Contrato**&#10;   - Nome do arquivo (PDF)&#10;   - Valor do contrato&#10;   - Porcentagem relativa (quando há múltiplos arquivos/aditivos)&#10;&#10;2. **Cálculo de Porcentagem**&#10;   - Valor de referência: primeiro arquivo com valor numérico&#10;   - Porcentagem = (valor do arquivo / valor de referência) × 100&#10;   - Exemplo:&#10;     ```&#10;     Contrato Principal: R$ 2.362.652,37 (100,00 %)&#10;     TA 1º: R$ 814.970,19 (34,49 %)&#10;     TA 2º: R$ 329.400,42 (13,94 %)&#10;     ```&#10;&#10;---&#10;&#10;## Alterações Realizadas&#10;&#10;### 1. API Route (`app/api/consulta-obra/route.ts`)&#10;&#10;#### ✅ Nova Busca de Arquivos do Contrato com Valores&#10;&#10;Adicionado código para buscar arquivos do sistema de contratos com valores:&#10;&#10;```typescript&#10;// Buscar arquivos do sistema de contratos (com valores)&#10;let arquivosContratoComValor: { nome: string; path: string; valor: number; historico_id: number }[] = [];&#10;&#10;if (contrato?.numero_contrato &amp;&amp; obra.contrato_numero) {&#10;  try {&#10;    // Buscar todos os contratos com esse numero_contratoh&#10;    const [contratosRelacionados] = await connectionContratos!.query&lt;RowDataPacket[]&gt;(&#10;      `SELECT id, valorh FROM historico WHERE numero_contratoh = ? ORDER BY id DESC`,&#10;      [obra.contrato_numero]&#10;    );&#10;    &#10;    if (contratosRelacionados &amp;&amp; contratosRelacionados.length &gt; 0) {&#10;      const contratoIds = contratosRelacionados.map((c: RowDataPacket) =&gt; c.id);&#10;      const placeholders = contratoIds.map(() =&gt; '?').join(',');&#10;      &#10;      // Buscar arquivos desses contratos&#10;      const [arquivosContratoDb] = await connectionContratos!.query&lt;RowDataPacket[]&gt;(&#10;        `SELECT nome_arquivo, path_servidor, historico_id &#10;         FROM arquivo &#10;         WHERE historico_id IN (${placeholders})&#10;         ORDER BY historico_id DESC`,&#10;        contratoIds&#10;      );&#10;      &#10;      // Mapear arquivos com valores&#10;      arquivosContratoComValor = (arquivosContratoDb as RowDataPacket[]).map((arq: RowDataPacket) =&gt; {&#10;        const contratoRelacionado = contratosRelacionados.find((c: RowDataPacket) =&gt; c.id === arq.historico_id);&#10;        return {&#10;          nome: arq.nome_arquivo as string,&#10;          path: arq.path_servidor as string,&#10;          valor: contratoRelacionado ? Number(contratoRelacionado.valorh) || 0 : 0,&#10;          historico_id: arq.historico_id as number&#10;        };&#10;      });&#10;    }&#10;  } catch (error) {&#10;    console.error(`Erro ao buscar arquivos do contrato ${obra.contrato_numero}:`, error);&#10;  }&#10;}&#10;```&#10;&#10;**Retorno da API agora inclui:**&#10;```typescript&#10;{&#10;  ...obra,&#10;  arquivos_contrato_valores: arquivosContratoComValor // NOVO CAMPO&#10;}&#10;```&#10;&#10;---&#10;&#10;### 2. Interfaces (`app/consulta-obra/page.tsx`)&#10;&#10;#### ✅ Nova Interface ArquivoContratoValor&#10;&#10;```typescript&#10;interface ArquivoContratoValor {&#10;  nome: string;&#10;  path: string;&#10;  valor: number;&#10;  historico_id: number;&#10;}&#10;&#10;interface Obra {&#10;  // ...campos existentes&#10;  arquivos_contrato_valores?: ArquivoContratoValor[]; // NOVO&#10;}&#10;```&#10;&#10;---&#10;&#10;### 3. Componente ObraDetalhes (`components/ObraDetalhes.tsx`)&#10;&#10;#### ✅ Seção de Arquivos do Contrato com Tabela&#10;&#10;Adicionada nova seção após &quot;Informações do Contrato&quot;:&#10;&#10;```tsx&#10;{/* Arquivos do Contrato com Valores */}&#10;{obra.arquivos_contrato_valores &amp;&amp; obra.arquivos_contrato_valores.length &gt; 0 &amp;&amp; (&#10;  &lt;div className=&quot;bg-white border-b border-gray-200 p-4&quot;&gt;&#10;    &lt;h3 className=&quot;text-lg font-semibold text-green-900 mb-3 flex items-center gap-2&quot;&gt;&#10;      &lt;span&gt;&lt;/span&gt; Arquivos do Contrato&#10;    &lt;/h3&gt;&#10;    &lt;div className=&quot;overflow-x-auto&quot;&gt;&#10;      &lt;table className=&quot;w-full border-collapse&quot;&gt;&#10;        &lt;thead&gt;&#10;          &lt;tr className=&quot;bg-green-800 text-white&quot;&gt;&#10;            &lt;th className=&quot;px-4 py-2 text-left text-sm font-semibold border border-green-700&quot;&gt;Arquivo&lt;/th&gt;&#10;            &lt;th className=&quot;px-4 py-2 text-right text-sm font-semibold border border-green-700&quot;&gt;Valor&lt;/th&gt;&#10;          &lt;/tr&gt;&#10;        &lt;/thead&gt;&#10;        &lt;tbody&gt;&#10;          {(() =&gt; {&#10;            // Determinar o valor de referência (primeiro valor numérico)&#10;            const valoresNumericos = obra.arquivos_contrato_valores!.filter(arq =&gt; arq.valor &gt; 0);&#10;            const valorReferencia = valoresNumericos.length &gt; 0 ? valoresNumericos[0].valor : 0;&#10;            const temMultiplosValores = valoresNumericos.length &gt; 1;&#10;&#10;            return obra.arquivos_contrato_valores!.map((arquivo, index) =&gt; {&#10;              const porcentagem = valorReferencia &gt; 0 ? (arquivo.valor / valorReferencia) * 100 : 0;&#10;              &#10;              return (&#10;                &lt;tr key={index} className=&quot;hover:bg-gray-50 border-b border-gray-200&quot;&gt;&#10;                  &lt;td className=&quot;px-4 py-3 border border-gray-200&quot;&gt;&#10;                    &lt;a href={`https://epamig.tech/contratos/web/${arquivo.path}`} target=&quot;_blank&quot;&gt;&#10;                       {arquivo.nome}&#10;                    &lt;/a&gt;&#10;                  &lt;/td&gt;&#10;                  &lt;td className=&quot;px-4 py-3 text-right border border-gray-200&quot;&gt;&#10;                    {arquivo.valor &gt; 0 ? (&#10;                      &lt;&gt;&#10;                        {formatarValor(arquivo.valor)}&#10;                        {temMultiplosValores &amp;&amp; porcentagem &gt; 0 &amp;&amp; (&#10;                          &lt;span className=&quot;text-sm font-bold text-green-700 bg-green-50 px-2 py-1 rounded ml-2&quot;&gt;&#10;                            ({porcentagem.toFixed(2).replace('.', ',')} %)&#10;                          &lt;/span&gt;&#10;                        )}&#10;                      &lt;/&gt;&#10;                    ) : (&#10;                      &lt;span className=&quot;text-gray-400 text-sm&quot;&gt;-&lt;/span&gt;&#10;                    )}&#10;                  &lt;/td&gt;&#10;                &lt;/tr&gt;&#10;              );&#10;            });&#10;          })()}&#10;        &lt;/tbody&gt;&#10;      &lt;/table&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;)}&#10;```&#10;&#10;---&#10;&#10;## Lógica de Cálculo de Porcentagem&#10;&#10;### Regras Implementadas:&#10;&#10;1. **Identificar Valor de Referência**&#10;   ```typescript&#10;   const valoresNumericos = obra.arquivos_contrato_valores.filter(arq =&gt; arq.valor &gt; 0);&#10;   const valorReferencia = valoresNumericos[0].valor; // Primeiro valor &gt; 0&#10;   ```&#10;&#10;2. **Calcular Porcentagem Relativa**&#10;   ```typescript&#10;   const porcentagem = (arquivo.valor / valorReferencia) * 100;&#10;   ```&#10;&#10;3. **Exibir Porcentagem Apenas se Houver Múltiplos Valores**&#10;   ```typescript&#10;   const temMultiplosValores = valoresNumericos.length &gt; 1;&#10;   &#10;   {temMultiplosValores &amp;&amp; porcentagem &gt; 0 &amp;&amp; (&#10;     &lt;span&gt;({porcentagem.toFixed(2)} %)&lt;/span&gt;&#10;   )}&#10;   ```&#10;&#10;4. **Formatação de Valores**&#10;   - Valores monetários: `formatarValor(valor)` → &quot;R$ 2.362.652,37&quot;&#10;   - Porcentagem: `toFixed(2).replace('.', ',')` → &quot;34,49&quot;&#10;&#10;---&#10;&#10;## Exemplo de Dados Retornados pela API&#10;&#10;```json&#10;{&#10;  &quot;id&quot;: 123,&#10;  &quot;numero_contrato&quot;: &quot;2023.303&quot;,&#10;  &quot;valor_contrato&quot;: 2362652.37,&#10;  &quot;arquivos_contrato_valores&quot;: [&#10;    {&#10;      &quot;nome&quot;: &quot;2023.303 - CONTRATO - URBANO ENGENHARIA.pdf&quot;,&#10;      &quot;path&quot;: &quot;uploads/contratos/2023.303_contrato.pdf&quot;,&#10;      &quot;valor&quot;: 2362652.37,&#10;      &quot;historico_id&quot;: 1001&#10;    },&#10;    {&#10;      &quot;nome&quot;: &quot;2023.303 - TA 1º - URBANO ENGENHARIA.pdf&quot;,&#10;      &quot;path&quot;: &quot;uploads/contratos/2023.303_ta1.pdf&quot;,&#10;      &quot;valor&quot;: 814970.19,&#10;      &quot;historico_id&quot;: 1002&#10;    },&#10;    {&#10;      &quot;nome&quot;: &quot;2023.303 - TA 2º - URBANO ENGENHARIA E CONSTRUÇÕES LTDA.pdf&quot;,&#10;      &quot;path&quot;: &quot;uploads/contratos/2023.303_ta2.pdf&quot;,&#10;      &quot;valor&quot;: 329400.42,&#10;      &quot;historico_id&quot;: 1003&#10;    }&#10;  ]&#10;}&#10;```&#10;&#10;---&#10;&#10;## Resultado Visual Esperado&#10;&#10;### Tabela de Arquivos do Contrato&#10;&#10;| Arquivo | Valor |&#10;|---------|-------|&#10;|  2023.303 - CONTRATO - URBANO ENGENHARIA.pdf | R$ 2.362.652,37 **(100,00 %)** |&#10;|  2023.303 - TA 1º - URBANO ENGENHARIA.pdf | R$ 814.970,19 **(34,49 %)** |&#10;|  2023.303 - TA 2º - URBANO ENGENHARIA E CONSTRUÇÕES LTDA.pdf | R$ 329.400,42 **(13,94 %)** |&#10;&#10;---&#10;&#10;## Fluxo de Dados&#10;&#10;```mermaid&#10;graph TD&#10;    A[Frontend - ObraDetalhes] --&gt;|Solicita dados da obra| B[API /api/consulta-obra]&#10;    B --&gt;|Busca obra no DB obras| C[Banco obras]&#10;    B --&gt;|Busca contrato no DB contratos| D[Banco contratos]&#10;    D --&gt;|SELECT historico WHERE numero_contratoh| E[Tabela historico]&#10;    D --&gt;|SELECT arquivo WHERE historico_id| F[Tabela arquivo]&#10;    F --&gt;|Retorna arquivos com valores| B&#10;    B --&gt;|Retorna obra + arquivos_contrato_valores| A&#10;    A --&gt;|Renderiza tabela com porcentagens| G[UI - Tabela]&#10;```&#10;&#10;---&#10;&#10;## Arquivos Modificados&#10;&#10;1. ✅ `app/api/consulta-obra/route.ts` - Busca de arquivos com valores&#10;2. ✅ `app/consulta-obra/page.tsx` - Interface ArquivoContratoValor&#10;3. ✅ `components/ObraDetalhes.tsx` - Componente de exibição da tabela&#10;&#10;---&#10;&#10;## Testes Recomendados&#10;&#10;1. ✅ Verificar se arquivos são buscados corretamente do banco de contratos&#10;2. ✅ Confirmar cálculo de porcentagem relativa&#10;3. ✅ Validar formatação de valores monetários&#10;4. ✅ Testar links de download dos arquivos&#10;5. ✅ Verificar responsividade da tabela em mobile&#10;6. ✅ Confirmar que porcentagem só aparece quando há múltiplos valores&#10;&#10;---&#10;&#10;## Diferenças em Relação ao Sistema Yii2/PHP&#10;&#10;### Sistema Yii2/PHP:&#10;- Busca arquivos diretamente na view&#10;- Usa helpers Yii para formatação&#10;- Calcula porcentagem no loop da view&#10;&#10;### Sistema Next.js (Implementado):&#10;- Busca arquivos na API route&#10;- Retorna dados estruturados&#10;- Calcula porcentagem no componente React&#10;- Mais eficiente e separação de responsabilidades&#10;&#10;---&#10;&#10;## Observações Importantes&#10;&#10;### Banco de Dados&#10;- Tabela `historico`: contém contratos com `valorh`&#10;- Tabela `arquivo`: contém PDFs vinculados a `historico_id`&#10;- Relacionamento: `arquivo.historico_id = historico.id`&#10;&#10;### Performance&#10;- Busca otimizada com IN clause&#10;- Cache pode ser adicionado futuramente&#10;- Considerar paginação para contratos com muitos aditivos&#10;&#10;### Segurança&#10;- Links apontam para domínio externo (epamig.tech)&#10;- Validar se usuário tem permissão para visualizar&#10;- Implementar autenticação no futuro&#10;&#10;---&#10;&#10;**Desenvolvedor:** GitHub Copilot  &#10;**Data:** 13/11/2025  &#10;**Status:** ✅ Implementado (aguardando teste de build)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/consulta-obra/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/consulta-obra/route.ts" />
              <option name="originalContent" value="import { NextRequest, NextResponse } from &quot;next/server&quot;;&#10;import { obrasDB, contratosDB } from &quot;@/lib/db&quot;;&#10;import { RowDataPacket, PoolConnection } from &quot;mysql2/promise&quot;;&#10;&#10;export async function GET(request: NextRequest) {&#10;  let connectionObras: PoolConnection | undefined;&#10;  let connectionContratos: PoolConnection | undefined;&#10;  &#10;  try {&#10;    // Obter parâmetros de filtro da URL&#10;    const { searchParams } = new URL(request.url);&#10;    const statusId = searchParams.get('status_id');&#10;    const unidadeId = searchParams.get('unidade_id');&#10;    &#10;    // Tentar obter conexão com banco de obras&#10;    connectionObras = await obrasDB.getConnection();&#10;    console.log(&quot;Conexão com banco de obras estabelecida&quot;);&#10;    &#10;  // Construir query com filtros dinâmicos&#10;  const whereConditions: string[] = [];&#10;  const queryParams: unknown[] = [];&#10;    &#10;    if (statusId &amp;&amp; statusId !== 'all') {&#10;      whereConditions.push('o.status_id = ?');&#10;      queryParams.push(parseInt(statusId));&#10;    }&#10;    &#10;    if (unidadeId &amp;&amp; unidadeId !== 'all') {&#10;      whereConditions.push('o.unidade_id = ?');&#10;      queryParams.push(parseInt(unidadeId));&#10;    }&#10;    &#10;    const whereClause = whereConditions.length &gt; 0 &#10;      ? `WHERE ${whereConditions.join(' AND ')}` &#10;      : '';&#10;    &#10;    // Buscar obras com nome da regional - conectar ao banco de contratos para ordenar&#10;    connectionContratos = await contratosDB.getConnection();&#10;    console.log(&quot;Conexão com banco de contratos estabelecida&quot;);&#10;    &#10;    // Buscar obras com nome da regional e número do contrato para ordenar por ano&#10;    const [obras] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#10;      `SELECT &#10;        o.id,&#10;        o.contrato_id,&#10;        o.contrato_numero,&#10;        o.status_id,&#10;        o.unidade_id,&#10;        r.nome as regional_nome&#10;       FROM (&#10;          SELECT &#10;              *,&#10;              ROW_NUMBER() OVER (PARTITION BY contrato_numero ORDER BY id DESC) as rn&#10;          FROM obra&#10;       ) o&#10;       LEFT JOIN regional r ON o.unidade_id = r.id&#10;       ${whereClause.replace('o.', '')}&#10;       AND o.rn = 1&#10;       ORDER BY o.contrato_id DESC, o.id DESC`,&#10;      queryParams&#10;    );&#10;&#10;    console.log(`Total de obras encontradas: ${obras.length}`);&#10;&#10;    // Filtrar apenas obras que possuem contrato_id válido&#10;    const obrasComContratoId = obras.filter(obra =&gt; &#10;      obra.contrato_id &amp;&amp; obra.contrato_id !== null &amp;&amp; obra.contrato_id &gt; 0&#10;    );&#10;    console.log(`Obras com contrato_id válido: ${obrasComContratoId.length} de ${obras.length}`);&#10;    &#10;    // Coletar IDs únicos de contratos para buscar em batch&#10;    const contratoIds = [...new Set(obrasComContratoId.map(obra =&gt; obra.contrato_id))];&#10;    console.log(`IDs únicos de contratos a buscar: ${contratoIds.join(', ')}`);&#10;    &#10;    // Buscar todos os contratos de uma vez (mais eficiente)&#10;    const contratosMap = new Map&lt;number, { numero_contrato?: string; objetoh?: string; valor?: number }&gt;();&#10;    if (contratoIds.length &gt; 0) {&#10;      const placeholders = contratoIds.map(() =&gt; '?').join(',');&#10;&#10;      // Primeiro tentar obter dados da tabela principal `contratos` (se existir)&#10;      try {&#10;        const [contratosPrincipais] = await connectionContratos.query&lt;RowDataPacket[]&gt;(&#10;          `SELECT id, numero_contrato as numero_contratoh, objeto as objetoh, valor&#10;           FROM contratos&#10;           WHERE id IN (${placeholders})`,&#10;          contratoIds&#10;        );&#10;&#10;        if (contratosPrincipais &amp;&amp; contratosPrincipais.length &gt; 0) {&#10;        contratosPrincipais.forEach((c: RowDataPacket) =&gt; {&#10;          const id = c.id as number;&#10;          contratosMap.set(id, {&#10;            numero_contrato: c.numero_contratoh as string,&#10;            objetoh: c.objetoh as string,&#10;            valor: Number(c.valor) || undefined,&#10;          });&#10;        });&#10;          console.log(`Contratos encontrados na tabela contratos: ${contratosPrincipais.length}`);&#10;        }&#10;      } catch {&#10;        // Se a tabela `contratos` não existir ou ocorrer erro, vamos usar o historico como fallback&#10;        console.log('Tabela `contratos` não disponível ou falha na consulta, usando `historico` como fallback.');&#10;      }&#10;&#10;      // Buscar dados no `historico` para todos os IDs — usar `valorh` como fonte primária do valor&#10;      const placeholdersHistAll = contratoIds.map(() =&gt; '?').join(',');&#10;      const [contratosHistAll] = await connectionContratos.query&lt;RowDataPacket[]&gt;(&#10;        `SELECT id, numero_contratoh, objetoh, dotacao_orcamentariah, valorh&#10;         FROM historico &#10;         WHERE id IN (${placeholdersHistAll})&#10;         ORDER BY CAST(SUBSTRING_INDEX(numero_contratoh, '/', 1) AS UNSIGNED) DESC, id DESC`,&#10;        contratoIds&#10;      );&#10;&#10;      contratosHistAll.forEach((contrato: RowDataPacket) =&gt; {&#10;        const id = contrato.id as number;&#10;        // Atualizar ou criar entrada no mapa — valor deve vir de valorh&#10;        const existing = contratosMap.get(id) || {};&#10;        contratosMap.set(id, {&#10;          numero_contrato: existing.numero_contrato || (contrato.numero_contratoh as string),&#10;          objetoh: existing.objetoh || (contrato.objetoh as string),&#10;          // Priorizar valorh do historico (valorh) como número&#10;          valor: Number(contrato.valorh as unknown) || undefined,&#10;        });&#10;        console.log(`✅ Contrato (hist) ${id}: ${contrato.numero_contratoh} - Valor: R$ ${contrato.valorh || 'NULL'}`);&#10;      });&#10;    }&#10;    &#10;    // Buscar informações dos contratos para cada obra&#10;    const obrasComContratos = await Promise.all(&#10;      obras.map(async (obra) =&gt; {&#10;        try {&#10;          console.log(`Processando obra ID ${obra.id}, contrato_id: ${obra.contrato_id}, status_id: ${obra.status_id}`);&#10;          &#10;          // Verificar se contrato_id existe e é válido&#10;          if (!obra.contrato_id || obra.contrato_id === null || obra.contrato_id === 0) {&#10;            console.log(`⚠️  Obra ${obra.id} sem contrato_id válido`);&#10;            &#10;            // Buscar arquivos mesmo sem contrato&#10;            let arquivos: RowDataPacket[] = [];&#10;            try {&#10;              const [result] = await connectionObras!.query&lt;RowDataPacket[]&gt;(&#10;                `SELECT id, tipo, nome_arquivo, path_servidor&#10;                 FROM arquivoobra &#10;                 WHERE obra_id = ? AND extensao = 'pdf' AND tipo != 'Contrato'&#10;                 ORDER BY id ASC`,&#10;                [obra.id]&#10;              );&#10;              arquivos = result || [];&#10;            } catch (arquivoError) {&#10;              console.error(`Erro ao buscar arquivos da obra ${obra.id}:`, arquivoError);&#10;            }&#10;            &#10;            return {&#10;              ...obra,&#10;              numero_contrato: null,&#10;              objeto_contrato: null,&#10;              valor_contrato: null,&#10;              arquivos: arquivos.map((arq: RowDataPacket) =&gt; ({&#10;                id: arq.id,&#10;                tipo: (arq.tipo as string) || 'PDF',&#10;                nome: (arq.nome_arquivo as string) || (arq.nome as string) || 'Arquivo sem nome',&#10;                url: `https://epamigsistema.com/obras/web/${arq.path_servidor}`&#10;              }))&#10;            };&#10;          }&#10;          &#10;          // Buscar dados do contrato no Map (já carregado)&#10;          const contrato = contratosMap.get(Number(obra.contrato_id));&#10;          &#10;          if (contrato) {&#10;            console.log(`✅ Contrato encontrado para obra ${obra.id}: ${contrato.numero_contrato} - Valor: R$ ${contrato.valor ?? 'NULL'}`);&#10;          } else {&#10;            console.log(`❌ Contrato ${obra.contrato_id} não encontrado para obra ${obra.id}`);&#10;          }&#10;          &#10;          // Buscar arquivos da obra - agrupados por contrato_numero&#10;          let arquivos: RowDataPacket[] = [];&#10;          let arquivosContrato: RowDataPacket[] = [];&#10;&#10;          try {&#10;            // Buscar arquivos da própria obra&#10;            const [result] = await connectionObras!.query&lt;RowDataPacket[]&gt;(&#10;              `SELECT id, tipo, nome_arquivo, path_servidor, obra_id&#10;               FROM arquivoobra &#10;               WHERE obra_id = ?&#10;               ORDER BY tipo ASC, id ASC`,&#10;              [obra.id]&#10;            );&#10;            arquivos = result || [];&#10;            console.log(` Arquivos para obra ${obra.id}: ${arquivos.length}`);&#10;&#10;            // Se a obra tem contrato, buscar também arquivos de outras obras com mesmo contrato_numero&#10;            if (contrato?.numero_contrato &amp;&amp; obra.contrato_numero) {&#10;              // Buscar todas as obras com mesmo contrato_numero&#10;              const [obrasRelacionadas] = await connectionObras!.query&lt;RowDataPacket[]&gt;(&#10;                `SELECT id FROM obra WHERE contrato_numero = ? AND id != ?`,&#10;                [obra.contrato_numero, obra.id]&#10;              );&#10;&#10;              if (obrasRelacionadas &amp;&amp; obrasRelacionadas.length &gt; 0) {&#10;                const obraIds = obrasRelacionadas.map((o: RowDataPacket) =&gt; o.id);&#10;                const placeholders = obraIds.map(() =&gt; '?').join(',');&#10;&#10;                // Buscar arquivos de todas as obras relacionadas&#10;                const [resultRelacionados] = await connectionObras!.query&lt;RowDataPacket[]&gt;(&#10;                  `SELECT id, tipo, nome_arquivo, path_servidor, obra_id&#10;                   FROM arquivoobra &#10;                   WHERE obra_id IN (${placeholders})&#10;                   ORDER BY obra_id ASC, tipo ASC, id ASC`,&#10;                  obraIds&#10;                );&#10;                arquivosContrato = resultRelacionados || [];&#10;                console.log(` Arquivos do contrato ${obra.contrato_numero}: ${arquivosContrato.length}`);&#10;              }&#10;            }&#10;          } catch (arquivoError) {&#10;            console.error(`Erro ao buscar arquivos da obra ${obra.id}:`, arquivoError);&#10;            arquivos = [];&#10;            arquivosContrato = [];&#10;          }&#10;          &#10;          return {&#10;            ...obra,&#10;            numero_contrato: contrato?.numero_contrato || null,&#10;            objeto_contrato: contrato?.objetoh || null,&#10;            valor_contrato: contrato?.valor ?? null,&#10;            arquivos: arquivos.map((arq: RowDataPacket) =&gt; ({&#10;              id: arq.id,&#10;              tipo: (arq.tipo as string) || 'Arquivo',&#10;              nome: (arq.nome_arquivo as string) || (arq.nome as string) || 'Arquivo sem nome',&#10;              url: `https://epamigsistema.com/obras/web/${arq.path_servidor}`,&#10;              obra_id: arq.obra_id&#10;            })),&#10;            arquivos_contrato: arquivosContrato.map((arq: RowDataPacket) =&gt; ({&#10;              id: arq.id,&#10;              tipo: (arq.tipo as string) || 'Arquivo',&#10;              nome: (arq.nome_arquivo as string) || (arq.nome as string) || 'Arquivo sem nome',&#10;              url: `https://epamigsistema.com/obras/web/${arq.path_servidor}`,&#10;              obra_id: arq.obra_id&#10;            }))&#10;          };&#10;        } catch (error) {&#10;          console.error(`❌ Erro ao processar obra ${obra.id}:`, error);&#10;          return {&#10;            ...obra,&#10;            numero_contrato: null,&#10;            objeto_contrato: null,&#10;            valor_contrato: null,&#10;            arquivos: []&#10;          };&#10;        }&#10;      })&#10;    );&#10;&#10;    // Buscar contagem por status para o gráfico (com filtros aplicados)&#10;    const [statusCount] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#10;      `SELECT &#10;          status_id,&#10;          COUNT(*) as total&#10;       FROM (&#10;          SELECT &#10;              o.contrato_numero,&#10;              ROW_NUMBER() OVER (PARTITION BY o.contrato_numero ORDER BY o.id DESC) as rn&#10;          FROM obra o&#10;          ${whereClause}&#10;       ) as subquery&#10;       WHERE rn = 1 AND contrato_numero IS NOT NULL&#10;       WHERE rn = 1&#10;       ORDER BY status_id ASC`,&#10;      queryParams&#10;    );&#10;&#10;    // Buscar lista de regionais para o filtro&#10;    const [regionais] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#10;      `SELECT id, nome FROM regional ORDER BY nome ASC`&#10;    );&#10;&#10;    console.log(`Total de status diferentes: ${statusCount.length}`);&#10;&#10;    // Ordenar obras pelo ano do contrato (primeiros 4 dígitos de numero_contrato) em ordem decrescente&#10;    const obrasOrdenadas = obrasComContratos.sort((a, b) =&gt; {&#10;      const anoA = a.numero_contrato ? parseInt(a.numero_contrato.split('/')[0]) : 0;&#10;      const anoB = b.numero_contrato ? parseInt(b.numero_contrato.split('/')[0]) : 0;&#10;      return anoB - anoA; // Ordem decrescente (ano mais recente primeiro)&#10;    });&#10;&#10;    return NextResponse.json({&#10;      success: true,&#10;      obras: obrasOrdenadas,&#10;      statusCount,&#10;      regionais,&#10;    });&#10;    &#10;  } catch (error: unknown) {&#10;    console.error(&quot;Erro detalhado ao buscar obras:&quot;, error);&#10;&#10;    // Type guard para erro do banco/SQL&#10;    const isDbError = (e: unknown): e is { code?: string; sqlMessage?: string; message?: string } =&gt; {&#10;      return typeof e === 'object' &amp;&amp; e !== null &amp;&amp; (&#10;        'code' in (e as object) || 'sqlMessage' in (e as object) || 'message' in (e as object)&#10;      );&#10;    };&#10;&#10;    // Verificar tipo de erro&#10;    let errorMessage = &quot;Erro ao buscar obras do banco de dados&quot;;&#10;&#10;    if (isDbError(error)) {&#10;      if (error.code === 'ECONNREFUSED') {&#10;        errorMessage = &quot;Não foi possível conectar ao banco de dados. Verifique se o MySQL está rodando.&quot;;&#10;      } else if (error.code === 'ER_NO_SUCH_TABLE') {&#10;        errorMessage = &quot;Tabela 'obra' não encontrada no banco de dados.&quot;;&#10;      } else if (error.code === 'ER_BAD_DB_ERROR') {&#10;        errorMessage = &quot;Banco de dados 'obra' não encontrado.&quot;;&#10;      } else if (error.sqlMessage) {&#10;        errorMessage = `Erro SQL: ${error.sqlMessage}`;&#10;      }&#10;    }&#10;&#10;    return NextResponse.json(&#10;      {&#10;        success: false,&#10;        error: errorMessage,&#10;        details: isDbError(error) &amp;&amp; error.message ? error.message : String(error),&#10;      },&#10;      { status: 500 }&#10;    );&#10;  } finally {&#10;    // Garantir que as conexões sejam liberadas&#10;    if (connectionObras) {&#10;      connectionObras.release();&#10;    }&#10;    if (connectionContratos) {&#10;      connectionContratos.release();&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from &quot;next/server&quot;;&#13;&#10;import { obrasDB, contratosDB } from &quot;@/lib/db&quot;;&#13;&#10;import { RowDataPacket, PoolConnection } from &quot;mysql2/promise&quot;;&#13;&#10;&#13;&#10;export async function GET(request: NextRequest) {&#13;&#10;  let connectionObras: PoolConnection | undefined;&#13;&#10;  let connectionContratos: PoolConnection | undefined;&#13;&#10;  &#13;&#10;  try {&#13;&#10;    // Obter parâmetros de filtro da URL&#13;&#10;    const { searchParams } = new URL(request.url);&#13;&#10;    const statusId = searchParams.get('status_id');&#13;&#10;    const unidadeId = searchParams.get('unidade_id');&#13;&#10;    &#13;&#10;    // Tentar obter conexão com banco de obras&#13;&#10;    connectionObras = await obrasDB.getConnection();&#13;&#10;    console.log(&quot;Conexão com banco de obras estabelecida&quot;);&#13;&#10;    &#13;&#10;  // Construir query com filtros dinâmicos&#13;&#10;  const whereConditions: string[] = [];&#13;&#10;  const queryParams: unknown[] = [];&#13;&#10;    &#13;&#10;    if (statusId &amp;&amp; statusId !== 'all') {&#13;&#10;      whereConditions.push('o.status_id = ?');&#13;&#10;      queryParams.push(parseInt(statusId));&#13;&#10;    }&#13;&#10;    &#13;&#10;    if (unidadeId &amp;&amp; unidadeId !== 'all') {&#13;&#10;      whereConditions.push('o.unidade_id = ?');&#13;&#10;      queryParams.push(parseInt(unidadeId));&#13;&#10;    }&#13;&#10;    &#13;&#10;    const whereClause = whereConditions.length &gt; 0 &#13;&#10;      ? `WHERE ${whereConditions.join(' AND ')}` &#13;&#10;      : '';&#13;&#10;    &#13;&#10;    // Buscar obras com nome da regional - conectar ao banco de contratos para ordenar&#13;&#10;    connectionContratos = await contratosDB.getConnection();&#13;&#10;    console.log(&quot;Conexão com banco de contratos estabelecida&quot;);&#13;&#10;    &#13;&#10;    // Buscar obras com nome da regional e número do contrato para ordenar por ano&#13;&#10;    const [obras] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#13;&#10;      `SELECT &#13;&#10;        o.id,&#13;&#10;        o.contrato_id,&#13;&#10;        o.contrato_numero,&#13;&#10;        o.status_id,&#13;&#10;        o.unidade_id,&#13;&#10;        r.nome as regional_nome&#13;&#10;       FROM (&#13;&#10;          SELECT &#13;&#10;              *,&#13;&#10;              ROW_NUMBER() OVER (PARTITION BY contrato_numero ORDER BY id DESC) as rn&#13;&#10;          FROM obra&#13;&#10;       ) o&#13;&#10;       LEFT JOIN regional r ON o.unidade_id = r.id&#13;&#10;       ${whereClause.replace('o.', '')}&#13;&#10;       AND o.rn = 1&#13;&#10;       ORDER BY o.contrato_id DESC, o.id DESC`,&#13;&#10;      queryParams&#13;&#10;    );&#13;&#10;&#13;&#10;    console.log(`Total de obras encontradas: ${obras.length}`);&#13;&#10;&#13;&#10;    // Filtrar apenas obras que possuem contrato_id válido&#13;&#10;    const obrasComContratoId = obras.filter(obra =&gt; &#13;&#10;      obra.contrato_id &amp;&amp; obra.contrato_id !== null &amp;&amp; obra.contrato_id &gt; 0&#13;&#10;    );&#13;&#10;    console.log(`Obras com contrato_id válido: ${obrasComContratoId.length} de ${obras.length}`);&#13;&#10;    &#13;&#10;    // Coletar IDs únicos de contratos para buscar em batch&#13;&#10;    const contratoIds = [...new Set(obrasComContratoId.map(obra =&gt; obra.contrato_id))];&#13;&#10;    console.log(`IDs únicos de contratos a buscar: ${contratoIds.join(', ')}`);&#13;&#10;    &#13;&#10;    // Buscar todos os contratos de uma vez (mais eficiente)&#13;&#10;    const contratosMap = new Map&lt;number, { numero_contrato?: string; objetoh?: string; valor?: number }&gt;();&#13;&#10;    if (contratoIds.length &gt; 0) {&#13;&#10;      const placeholders = contratoIds.map(() =&gt; '?').join(',');&#13;&#10;&#13;&#10;      // Primeiro tentar obter dados da tabela principal `contratos` (se existir)&#13;&#10;      try {&#13;&#10;        const [contratosPrincipais] = await connectionContratos.query&lt;RowDataPacket[]&gt;(&#13;&#10;          `SELECT id, numero_contrato as numero_contratoh, objeto as objetoh, valor&#13;&#10;           FROM contratos&#13;&#10;           WHERE id IN (${placeholders})`,&#13;&#10;          contratoIds&#13;&#10;        );&#13;&#10;&#13;&#10;        if (contratosPrincipais &amp;&amp; contratosPrincipais.length &gt; 0) {&#13;&#10;        contratosPrincipais.forEach((c: RowDataPacket) =&gt; {&#13;&#10;          const id = c.id as number;&#13;&#10;          contratosMap.set(id, {&#13;&#10;            numero_contrato: c.numero_contratoh as string,&#13;&#10;            objetoh: c.objetoh as string,&#13;&#10;            valor: Number(c.valor) || undefined,&#13;&#10;          });&#13;&#10;        });&#13;&#10;          console.log(`Contratos encontrados na tabela contratos: ${contratosPrincipais.length}`);&#13;&#10;        }&#13;&#10;      } catch {&#13;&#10;        // Se a tabela `contratos` não existir ou ocorrer erro, vamos usar o historico como fallback&#13;&#10;        console.log('Tabela `contratos` não disponível ou falha na consulta, usando `historico` como fallback.');&#13;&#10;      }&#13;&#10;&#13;&#10;      // Buscar dados no `historico` para todos os IDs — usar `valorh` como fonte primária do valor&#13;&#10;      const placeholdersHistAll = contratoIds.map(() =&gt; '?').join(',');&#13;&#10;      const [contratosHistAll] = await connectionContratos.query&lt;RowDataPacket[]&gt;(&#13;&#10;        `SELECT id, numero_contratoh, objetoh, dotacao_orcamentariah, valorh&#13;&#10;         FROM historico &#13;&#10;         WHERE id IN (${placeholdersHistAll})&#13;&#10;         ORDER BY CAST(SUBSTRING_INDEX(numero_contratoh, '/', 1) AS UNSIGNED) DESC, id DESC`,&#13;&#10;        contratoIds&#13;&#10;      );&#13;&#10;&#13;&#10;      contratosHistAll.forEach((contrato: RowDataPacket) =&gt; {&#13;&#10;        const id = contrato.id as number;&#13;&#10;        // Atualizar ou criar entrada no mapa — valor deve vir de valorh&#13;&#10;        const existing = contratosMap.get(id) || {};&#13;&#10;        contratosMap.set(id, {&#13;&#10;          numero_contrato: existing.numero_contrato || (contrato.numero_contratoh as string),&#13;&#10;          objetoh: existing.objetoh || (contrato.objetoh as string),&#13;&#10;          // Priorizar valorh do historico (valorh) como número&#13;&#10;          valor: Number(contrato.valorh as unknown) || undefined,&#13;&#10;        });&#13;&#10;        console.log(`✅ Contrato (hist) ${id}: ${contrato.numero_contratoh} - Valor: R$ ${contrato.valorh || 'NULL'}`);&#13;&#10;      });&#13;&#10;    }&#13;&#10;    &#13;&#10;    // Buscar informações dos contratos para cada obra&#13;&#10;    const obrasComContratos = await Promise.all(&#13;&#10;      obras.map(async (obra) =&gt; {&#13;&#10;        try {&#13;&#10;          console.log(`Processando obra ID ${obra.id}, contrato_id: ${obra.contrato_id}, status_id: ${obra.status_id}`);&#13;&#10;          &#13;&#10;          // Verificar se contrato_id existe e é válido&#13;&#10;          if (!obra.contrato_id || obra.contrato_id === null || obra.contrato_id === 0) {&#13;&#10;            console.log(`⚠️  Obra ${obra.id} sem contrato_id válido`);&#13;&#10;            &#13;&#10;            // Buscar arquivos mesmo sem contrato&#13;&#10;            let arquivos: RowDataPacket[] = [];&#13;&#10;            try {&#13;&#10;              const [result] = await connectionObras!.query&lt;RowDataPacket[]&gt;(&#13;&#10;                `SELECT id, tipo, nome_arquivo, path_servidor&#13;&#10;                 FROM arquivoobra &#13;&#10;                 WHERE obra_id = ? AND extensao = 'pdf' AND tipo != 'Contrato'&#13;&#10;                 ORDER BY id ASC`,&#13;&#10;                [obra.id]&#13;&#10;              );&#13;&#10;              arquivos = result || [];&#13;&#10;            } catch (arquivoError) {&#13;&#10;              console.error(`Erro ao buscar arquivos da obra ${obra.id}:`, arquivoError);&#13;&#10;            }&#13;&#10;            &#13;&#10;            return {&#13;&#10;              ...obra,&#13;&#10;              numero_contrato: null,&#13;&#10;              objeto_contrato: null,&#13;&#10;              valor_contrato: null,&#13;&#10;              arquivos: arquivos.map((arq: RowDataPacket) =&gt; ({&#13;&#10;                id: arq.id,&#13;&#10;                tipo: (arq.tipo as string) || 'PDF',&#13;&#10;                nome: (arq.nome_arquivo as string) || (arq.nome as string) || 'Arquivo sem nome',&#13;&#10;                url: `https://epamigsistema.com/obras/web/${arq.path_servidor}`&#13;&#10;              }))&#13;&#10;            };&#13;&#10;          }&#13;&#10;          &#13;&#10;          // Buscar dados do contrato no Map (já carregado)&#13;&#10;          const contrato = contratosMap.get(Number(obra.contrato_id));&#13;&#10;          &#13;&#10;          if (contrato) {&#13;&#10;            console.log(`✅ Contrato encontrado para obra ${obra.id}: ${contrato.numero_contrato} - Valor: R$ ${contrato.valor ?? 'NULL'}`);&#13;&#10;          } else {&#13;&#10;            console.log(`❌ Contrato ${obra.contrato_id} não encontrado para obra ${obra.id}`);&#13;&#10;          }&#13;&#10;          &#13;&#10;          // Buscar arquivos da obra - agrupados por contrato_numero&#13;&#10;          let arquivos: RowDataPacket[] = [];&#13;&#10;          let arquivosContrato: RowDataPacket[] = [];&#13;&#10;&#13;&#10;          try {&#13;&#10;            // Buscar arquivos da própria obra&#13;&#10;            const [result] = await connectionObras!.query&lt;RowDataPacket[]&gt;(&#13;&#10;              `SELECT id, tipo, nome_arquivo, path_servidor, obra_id&#13;&#10;               FROM arquivoobra &#13;&#10;               WHERE obra_id = ?&#13;&#10;               ORDER BY tipo ASC, id ASC`,&#13;&#10;              [obra.id]&#13;&#10;            );&#13;&#10;            arquivos = result || [];&#13;&#10;            console.log(` Arquivos para obra ${obra.id}: ${arquivos.length}`);&#13;&#10;&#13;&#10;            // Se a obra tem contrato, buscar também arquivos de outras obras com mesmo contrato_numero&#13;&#10;            if (contrato?.numero_contrato &amp;&amp; obra.contrato_numero) {&#13;&#10;              // Buscar todas as obras com mesmo contrato_numero&#13;&#10;              const [obrasRelacionadas] = await connectionObras!.query&lt;RowDataPacket[]&gt;(&#13;&#10;                `SELECT id FROM obra WHERE contrato_numero = ? AND id != ?`,&#13;&#10;                [obra.contrato_numero, obra.id]&#13;&#10;              );&#13;&#10;&#13;&#10;              if (obrasRelacionadas &amp;&amp; obrasRelacionadas.length &gt; 0) {&#13;&#10;                const obraIds = obrasRelacionadas.map((o: RowDataPacket) =&gt; o.id);&#13;&#10;                const placeholders = obraIds.map(() =&gt; '?').join(',');&#13;&#10;&#13;&#10;                // Buscar arquivos de todas as obras relacionadas&#13;&#10;                const [resultRelacionados] = await connectionObras!.query&lt;RowDataPacket[]&gt;(&#13;&#10;                  `SELECT id, tipo, nome_arquivo, path_servidor, obra_id&#13;&#10;                   FROM arquivoobra &#13;&#10;                   WHERE obra_id IN (${placeholders})&#13;&#10;                   ORDER BY obra_id ASC, tipo ASC, id ASC`,&#13;&#10;                  obraIds&#13;&#10;                );&#13;&#10;                arquivosContrato = resultRelacionados || [];&#13;&#10;                console.log(` Arquivos do contrato ${obra.contrato_numero}: ${arquivosContrato.length}`);&#13;&#10;              }&#13;&#10;            }&#13;&#10;          } catch (arquivoError) {&#13;&#10;            console.error(`Erro ao buscar arquivos da obra ${obra.id}:`, arquivoError);&#13;&#10;            arquivos = [];&#13;&#10;            arquivosContrato = [];&#13;&#10;          }&#13;&#10;          &#13;&#10;          // Buscar arquivos do sistema de contratos (com valores)&#10;          let arquivosContratoComValor: { nome: string; path: string; valor: number; historico_id: number }[] = [];&#10;          &#10;          if (contrato?.numero_contrato &amp;&amp; obra.contrato_numero) {&#10;            try {&#10;              // Buscar todos os contratos com esse numero_contratoh&#10;              const [contratosRelacionados] = await connectionContratos!.query&lt;RowDataPacket[]&gt;(&#10;                `SELECT id, valorh FROM historico WHERE numero_contratoh = ? ORDER BY id DESC`,&#10;                [obra.contrato_numero]&#10;              );&#10;              &#10;              if (contratosRelacionados &amp;&amp; contratosRelacionados.length &gt; 0) {&#10;                const contratoIds = contratosRelacionados.map((c: RowDataPacket) =&gt; c.id);&#10;                const placeholders = contratoIds.map(() =&gt; '?').join(',');&#10;                &#10;                // Buscar arquivos desses contratos&#10;                const [arquivosContratoDb] = await connectionContratos!.query&lt;RowDataPacket[]&gt;(&#10;                  `SELECT nome_arquivo, path_servidor, historico_id &#10;                   FROM arquivo &#10;                   WHERE historico_id IN (${placeholders})&#10;                   ORDER BY historico_id DESC`,&#10;                  contratoIds&#10;                );&#10;                &#10;                // Mapear arquivos com valores&#10;                arquivosContratoComValor = (arquivosContratoDb as RowDataPacket[]).map((arq: RowDataPacket) =&gt; {&#10;                  const contratoRelacionado = contratosRelacionados.find((c: RowDataPacket) =&gt; c.id === arq.historico_id);&#10;                  return {&#10;                    nome: arq.nome_arquivo as string,&#10;                    path: arq.path_servidor as string,&#10;                    valor: contratoRelacionado ? Number(contratoRelacionado.valorh) || 0 : 0,&#10;                    historico_id: arq.historico_id as number&#10;                  };&#10;                });&#10;              }&#10;            } catch (error) {&#10;              console.error(`Erro ao buscar arquivos do contrato ${obra.contrato_numero}:`, error);&#10;            }&#10;          }&#10;&#10;          return {&#10;            ...obra,&#10;            numero_contrato: contrato?.numero_contrato || null,&#10;            objeto_contrato: contrato?.objetoh || null,&#10;            valor_contrato: contrato?.valor ?? null,&#10;            arquivos: arquivos.map((arq: RowDataPacket) =&gt; ({&#10;              id: arq.id,&#10;              tipo: (arq.tipo as string) || 'Arquivo',&#10;              nome: (arq.nome_arquivo as string) || (arq.nome as string) || 'Arquivo sem nome',&#10;              url: `https://epamigsistema.com/obras/web/${arq.path_servidor}`,&#10;              obra_id: arq.obra_id&#10;            })),&#10;            arquivos_contrato: arquivosContrato.map((arq: RowDataPacket) =&gt; ({&#10;              id: arq.id,&#10;              tipo: (arq.tipo as string) || 'Arquivo',&#10;              nome: (arq.nome_arquivo as string) || (arq.nome as string) || 'Arquivo sem nome',&#10;              url: `https://epamigsistema.com/obras/web/${arq.path_servidor}`,&#10;              obra_id: arq.obra_id&#10;            })),&#10;            arquivos_contrato_valores: arquivosContratoComValor&#10;          };&#13;&#10;        } catch (error) {&#13;&#10;          console.error(`❌ Erro ao processar obra ${obra.id}:`, error);&#13;&#10;          return {&#13;&#10;            ...obra,&#13;&#10;            numero_contrato: null,&#13;&#10;            objeto_contrato: null,&#13;&#10;            valor_contrato: null,&#13;&#10;            arquivos: []&#13;&#10;          };&#13;&#10;        }&#13;&#10;      })&#13;&#10;    );&#13;&#10;&#13;&#10;    // Buscar contagem por status para o gráfico (com filtros aplicados)&#13;&#10;    // Agrupa por contrato_numero e pega o status_id do último registro (maior id)&#13;&#10;    const [statusCount] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#13;&#10;      `SELECT &#13;&#10;          status_id,&#13;&#10;          COUNT(DISTINCT contrato_numero) as total&#13;&#10;       FROM (&#13;&#10;          SELECT &#13;&#10;              o.contrato_numero,&#13;&#10;              o.status_id,&#13;&#10;              ROW_NUMBER() OVER (PARTITION BY o.contrato_numero ORDER BY o.id DESC) as rn&#13;&#10;          FROM obra o&#13;&#10;          ${whereClause}&#13;&#10;       ) as subquery&#13;&#10;       WHERE rn = 1 AND contrato_numero IS NOT NULL&#13;&#10;       GROUP BY status_id&#13;&#10;       ORDER BY status_id ASC`,&#13;&#10;      queryParams&#13;&#10;    );&#13;&#10;&#13;&#10;    // Buscar lista de regionais para o filtro&#13;&#10;    const [regionais] = await connectionObras.query&lt;RowDataPacket[]&gt;(&#13;&#10;      `SELECT id, nome FROM regional ORDER BY nome ASC`&#13;&#10;    );&#13;&#10;&#13;&#10;    console.log(`Total de status diferentes: ${statusCount.length}`);&#13;&#10;&#13;&#10;    // Ordenar obras pelo ano do contrato (primeiros 4 dígitos de numero_contrato) em ordem decrescente&#13;&#10;    const obrasOrdenadas = obrasComContratos.sort((a, b) =&gt; {&#13;&#10;      const anoA = a.numero_contrato ? parseInt(a.numero_contrato.split('/')[0]) : 0;&#13;&#10;      const anoB = b.numero_contrato ? parseInt(b.numero_contrato.split('/')[0]) : 0;&#13;&#10;      return anoB - anoA; // Ordem decrescente (ano mais recente primeiro)&#13;&#10;    });&#13;&#10;&#13;&#10;    return NextResponse.json({&#13;&#10;      success: true,&#13;&#10;      obras: obrasOrdenadas,&#13;&#10;      statusCount,&#13;&#10;      regionais,&#13;&#10;    });&#13;&#10;    &#13;&#10;  } catch (error: unknown) {&#13;&#10;    console.error(&quot;Erro detalhado ao buscar obras:&quot;, error);&#13;&#10;&#13;&#10;    // Type guard para erro do banco/SQL&#13;&#10;    const isDbError = (e: unknown): e is { code?: string; sqlMessage?: string; message?: string } =&gt; {&#13;&#10;      return typeof e === 'object' &amp;&amp; e !== null &amp;&amp; (&#13;&#10;        'code' in (e as object) || 'sqlMessage' in (e as object) || 'message' in (e as object)&#13;&#10;      );&#13;&#10;    };&#13;&#10;&#13;&#10;    // Verificar tipo de erro&#13;&#10;    let errorMessage = &quot;Erro ao buscar obras do banco de dados&quot;;&#13;&#10;&#13;&#10;    if (isDbError(error)) {&#13;&#10;      if (error.code === 'ECONNREFUSED') {&#13;&#10;        errorMessage = &quot;Não foi possível conectar ao banco de dados. Verifique se o MySQL está rodando.&quot;;&#13;&#10;      } else if (error.code === 'ER_NO_SUCH_TABLE') {&#13;&#10;        errorMessage = &quot;Tabela 'obra' não encontrada no banco de dados.&quot;;&#13;&#10;      } else if (error.code === 'ER_BAD_DB_ERROR') {&#13;&#10;        errorMessage = &quot;Banco de dados 'obra' não encontrado.&quot;;&#13;&#10;      } else if (error.sqlMessage) {&#13;&#10;        errorMessage = `Erro SQL: ${error.sqlMessage}`;&#13;&#10;      }&#13;&#10;    }&#13;&#10;&#13;&#10;    return NextResponse.json(&#13;&#10;      {&#13;&#10;        success: false,&#13;&#10;        error: errorMessage,&#13;&#10;        details: isDbError(error) &amp;&amp; error.message ? error.message : String(error),&#13;&#10;      },&#13;&#10;      { status: 500 }&#13;&#10;    );&#13;&#10;  } finally {&#13;&#10;    // Garantir que as conexões sejam liberadas&#13;&#10;    if (connectionObras) {&#13;&#10;      connectionObras.release();&#13;&#10;    }&#13;&#10;    if (connectionContratos) {&#13;&#10;      connectionContratos.release();&#13;&#10;    }&#13;&#10;  }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>